\documentclass[12pt]{scrreprt}

% satz nach der norm auf der tu-seite

% referenzenh
\usepackage{cite}
\usepackage{bibgerm}

% farben definieren
\usepackage{xcolor}
\definecolor{lightblue}{cmyk}{0.346, 0.114, 0, 0.106}


% zeilenabstand (nach dem dokument auf der tu-seite)
\usepackage[onehalfspacing]{setspace}

% deutsch
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

% mathe pakete
\usepackage{amsmath,amssymb,amstext}

% einfach bilder einbinden
\usepackage{graphicx}

% fußnoten immer am ende
\usepackage{footnote}
\usepackage[bottom]{footmisc}

% tabellen
\usepackage[margin=10pt,labelfont=bf]{caption} %abstand zwischen caption und tabelle und fette caption nummer
\usepackage{booktabs}

% codeblöcke
\usepackage{listings}

% abkürzungen
\usepackage[printonlyused,withpage]{acronym}

% bessere listen
\usepackage{enumitem}
\setlist{noitemsep} % entfernen der abstände zwischen den verschiedenen items (naja so halb der rest kommt vom zeilenabstand)

% bessere links (sollte als letztes paket geladen werden)
\usepackage[colorlinks=false]{hyperref}



\titlehead{Technische Universität Berlin\\Fakultät IV (Elektrotechnik und Informatik)\\Institut für Softwaretechnik und Theoretische Informatik\\Fachgebiet Übersetzerbau und Programmiersprachen\\Franklinstr. 28/29\\10587 Berlin}
\subject{Diplomarbeit}
\title{Integration von funktionalen Web-Client- und Server-Sprachen am Beispiel von SL und Scala}
\author{Tom Landvoigt, Matrikelnummer: 222115}
\publishers
{
  \begin{tabular}{ll}
    Prüfer:   & Prof. Dr. Peter Pepper\\
              & Prof. Dr.-Ing. Stefan Jähnichen\\
    Betreuer: & Martin Zuber\\
              & Christoph Höger\\
  \end{tabular}
}
\date{\today{}, Berlin}

% DOCUMENT BEGIN 
\begin{document}
\pagenumbering{roman}
\maketitle
\tableofcontents   % Inhaltsverzeichnis
\listoffigures     % Abbildungsverzeichnis
\listoftables      % Tabellenverzeichnis
\lstlistoflistings % Listingverzeichnis

\chapter*{Abkürzungsverzeichnis}
\begin{acronym}[TU-Berlin]
\setlength{\itemsep}{-0.3\parsep}
 \acro{SL}{Simple Language}
 \acro{JS}{JavaScript}
 \acro{AST}{Abstract Syntax Tree}
 \acro{TUB}{Technische Universität Berlin}
 \acro{}{}
 \acro{MVC}{Model View Controller}
 \acro{HTML}{Hypertext Markup Language}
 \acro{DOM}{Document Object Model}
 \acro{URL}{Uniform Resource Locator}
\end{acronym}


\newpage
\thispagestyle{empty}		% ohne Kopf und Fußzeilen
\begin{LARGE}
	\textbf{Erklärung}
\end{LARGE}

\vspace{1cm}

Hiermit erkläre ich, dass ich die vorliegende Arbeit selbstständig und eigenhändig sowie ohne unerlaubte fremde Hilfe und ausschließlich unter Verwendung der aufgeführten Quellen und Hilfsmittel angefertigt habe.
\vspace{2cm}

Berlin, den \today

\vspace{1cm}
%\rule{_Breite_}{_Stärke_}		%andersrum ist's vertikal

\rule{0.3\textwidth}{0.4pt}

Unterschrift

%\Datum
\vspace*{6cm}
\newpage

\pagenumbering{arabic}

% set style for code blocks
\lstset{basicstyle=\ttfamily\small, numbers=left, numberstyle=\tiny}

\chapter*{Einleitung}
\setcounter{page}{1}
\addcontentsline{toc}{chapter}{Einleitung}

Das World Wide Web ist ein integraler Bestandteil unseres Lebens geworden. Ein großer Teil der Software mit der wir in Berührung kommen, benutzt Webseiten als Benutzerschnittstelle. Deshalb muss sich jede moderne Programmiersprache daran messen lassen wie leicht es ist mit ihr Webprojekte zu erstellen. Daher bieten Java, Scala, Ruby und viele andere Programmiersprachen Frameworks an um schnell und einfach strukturierte Webprojekte zu erstellen. Ein gemeinsames Problem dieser Frameworks ist es, insbesondere mit dem aufkommen von Rich Internet Applications, das clientseitig Code ausgeführt werden muss. In diesem Bereich hat sich JavaScript (JS) zum Quasistandard entwickelt\footnote{Es gibt weitere Alternativen wie Java oder Flash, die aber Browserplugins vorraussetzen.}. Dadurch ist man beim Schreiben von Browser-seitigen Funktionen auf die von den JS-Entwicklern bevorzugten Programmierparadigmen wie dynamische Typisierung festgelegt. Bei größeren Bibliotheken kann dies die Wartung und Weiterentwicklung erschweren.

Innerhalb der letzten Jahre kam es zu Entwicklungen die eine mögliche Lösung für dieses Problem bieten. Einerseits haben Büchle et al. im Rahmen eines Projektes an der \ac{TUB} einen Compiler entwickelt, der die Typ-sichere, funktionale Sprache Simple Language (SL) nach JS übersetzt\cite{Buchle2013}. Andererseits wurde durch die Einführung von compiler makros \cite{Burmako2013}, die Metaprogrammierung innerhalb von Scala erheblich vereinfacht.

Mit Hilfe dieser beiden Voraussetzungen konnte SL als Abstraktion für JS in Scala eingebettet werden\cite{Hoger2013} um Probleme mit der dynamischen Typisierung von JS zu lösen. Dazu wurde eine Beispielanwendung im Play Framework geschrieben\cite{Play1}. 

Diese Einbettung wurde im Zuge dieser Diplomarbeit erweitert. Nun ist es  möglich Scala-Funktionen und -Werte in einem gewissen Rahmen automatisch zu übersetzen und typsicher im SL Code zu benutzen. 

Mit Scala Werten ist der Inhalt einer Scala Variable gemeint. Wenn dieser sich in SL abbilden lässt, kann er jetzt in statischen SL Code eingebunden werden. Für Scala-Funktionen werden eine SL Funktionen erzeugt, die dann die entsprechenden Scala-Funktionen aufrufen, falls sich die Ein- und Rückgabetypen in SL Typen übersetzen lassen.

Dazu wurde die Möglichkeit geschaffen Scala Type und Werte in SL zu übersetzen sowie zwei Makros geschrieben, die die Einbettung von SL in Scala ermöglichen. 

Für das Verständnis der Diplomarbeit werden Kenntnisse im Bereich funktionaler Programmierung sowie Grundlagen in den Sprachen Scala und JS vorausgesetzt.

Im \ref{cha:sl-introduction}. Kapitel wird die Sprache SL kurz vorgestellt. Daraufhin wird beschrieben wie Scala Typen und Werte in SL übersetzt werden (Kapitel \ref{cha:model-sharing}). Dies wird im \ref{chap:scala-compiler-macros}. Kapitel benutzt um mit Hilfe der dort beschriebenen Makros SL in Scala einzubetten. Darauf hin wird kurz auf den SL Compiler eingegangen und welche Erweiterungen im Zuge dieser Arbeit an ihm gemacht wurden. Abschließend wird diese Einbettung von JS in Scala mit anderen Varianten aus dem Scala Universum verglichen (Kapitel \ref{chap:related-works}). 

\chapter{Einführung in Simple Language}
\label{cha:sl-introduction}

Zunächst wird im diesem Kapitel die Sprache SL vorgestellt, da sie essenziell für das Verständnis dieser Arbeit ist.

SL ist eine einfache strikt getypte funktionale Sprache, die als Lehrsprache für den Studienbetrieb der \ac{TUB} entwickelt wurde. SL hat einen sehr einfach modularen Compiler. Das ermöglicht es leicht neuer Konzepte aus zu probieren. In den folgenden Abschnitten werden die für diese Arbeit relevanten Eigenschaften erklärt.

\section{Struktur eines SL Programms}

Im Rahmen des Compilerbauprojekts im Sommersemester 2013 wurde SL von den Studierenden um die Möglichkeit der Modularisierung erweitert \cite{Bisping2013}. Daher besteht ein SL-Programm aus einer Menge von Modulen. Ein Modul ist eine Quelldatei mit der Endung '.sl'. In ihm können Funktionen und Typen definiert werden. Durch die Übersetzung eines SL Moduls werden zwei Dateien erzeugt. Die Datei mit der Endung '.ls.js' enthält den ausführbaren JS-Code. Die zweite Datei mit der Endung '.signature' enthält Informationen darüber welche Funktionen und Datentypen in anderen Modulen verwendet werden können. Das Modul prelude.sl beschreibt alle vordefinierten Funktionen und Datentypen und wird in alle Programme eingebunden. 

%require.js erwähnen

\section{Syntax von SL}

Im folgenden wird die Syntax von SL anhand des Beispielprogramms in Listing \ref{lst:example-modul} erklärt.

\begin{lstlisting}[caption=Beispielmodul, label=lst:example-modul, float=h]
-- Kommentar

IMPORT "std/basicweb" AS Web
IMPORT EXTERN "foo/_bar"

DATA StringOrOther a = Nothing | StringVal String | OtherVal a

PUBLIC FUN getOtherOrElse : StringOrOther a -> a -> a
DEF getString (OtherVal x) y = x
DEF getString x y = y

PUBLIC FUN main : DOM Void
DEF main = Web.alert(intToString (getOtherOrElse(exampleVar, 3)))

FUN exampleVar : StringOrOther Int
DEF exampleVar = OtherVal 5

FUN getDocumentHight : DOM Int
DEF getDocumentHight = {| window.outerHeight |} : DOM Int

\end{lstlisting}

\subsection{Import von Modulen}

Mit \lstinline!IMPORT "<Pfad>" AS <Bezeichner>! können Module nachgeladen werden. Typen und Funktionen die aus Fremdmodulen benutzt werden müssen mit dem \lstinline!<Bezeichner>! qualifiziert werden. Ein Beispiel dafür ist \lstinline!Web.alert(...)!. 
  
  Mit \lstinline!IMPORT EXTERN! können \ac{JS}-Quelldateien eingebunden werden. In diesem Fall wird der Inhalt der Datei \lstinline!\_bar.js! im Ordner \lstinline!foo! an den Anfang des Kompilats kopiert.

\subsection{Basistypen}

\lstinline!DOM a! und \lstinline!Void! sind einige der Vordefinierten Typen. \lstinline!Void! bezeichnet den leeren Typen, also keinen Rückgabewert. \lstinline!DOM a! ist der Typ der \ac{JS}-quoating Monade. Mit ihr können \ac{JS} Snippets in \ac{SL} eingebunden werden (Beispiel: \lstinline!{| window.outerHeight |} : DOM Int!). Weiter vordefinierte Typen sind \lstinline!Char! und \lstinline!String! um Zeichen(ketten) darzustellen, sowie \lstinline!Int! für ganzzahlige Werte und \lstinline!Real! für Gleitkommazahlen. Der letzte vordefinierte Typ ist \lstinline!Bool! für boolesche Werte.
  
\subsection{Funktionsdefintionen}

Die optionale Signatur einer Funktion kann mit \lstinline!FUN <Funktionsname> : <Typ>! angegeben werden. Wenn ein \lstinline!PUBLIC! vorgestellt wird, ist die Funktion auch außerhalb des Moduls sichtbar. Darauf folgen eine oder mehrere pattern basierte Funktionsdefinition der Form \lstinline!DEF <Funktionsname> = <Funktionsrumpf>!.


\subsection{Programmeinstiegspunkt}

Ein Spezialfall bildet die Funktion \lstinline!main!. Sie bildet den Einstiegspunkt in ein \ac{SL} Programm. Sie hat den festen Typ \lstinline!DOM Void!. 

\subsection{Typdefinitionen}

Mit \lstinline!DATA <Typname> [<Typprameter> ...] = <Konstruktor> [<Typparameter> ...] | ...! können eigene Typen definiert werden. Wie wir Scala Typen und Werte nach \ac{SL} und zurück übersetzen wird Stoff des Kapitels \ref{cha:model-sharing} sein.

\chapter{Model Sharing}
\label{cha:model-sharing}

Im Zuge dieser Arbeit sollten Scala-Werte und -Funktionen in SL eingebettet werden. Dazu muss einem Scala Typ ein SL Typ zugeordnet und ihre Werte in einander überführt werden. Dies wird im allgemeinen unter dem Begriff Model Sharing zusammengefasst.
Betrachten wir dazu beispielhaft die Scala Funktion \lstinline!scala_foo! im Listing \ref{lst:scala-fun-example}.

\begin{lstlisting}[caption=Beispielfunktion scala\_foo, label=lst:scala-fun-example]
def foo( i: Float ): Double = {...}
\end{lstlisting}

Für die Typen \lstinline!Float! und \lstinline!Double! müssen wir ihre \ac{SL}-Entsprechung finden. Um die Implementation zu vereinfachen setzen wir voraus, das jedem Scala Typ genau ein \ac{SL}-Typ zugeordnet wird. Andernfalls müssten wir für alle möglichen Permutationen einen \ac{SL}-Funktionsrumpf erstellen. Bei eingebetteten Scala Werten müsste der SL-Code analysiert werden, um die passende Übersetzung zu finden\footnote{Das ist keine besonders große Einschränkung, da wie wir später sehen werden, das das Typsystem von SL sehr einfach ist und dadurch viele Scala-Typen auf ein und den selben SL Typen abgebildet werden. }. Wir erhalten die partielle Funktion $translate_{type}(Type_{Scala}) = Type_{SL}$. Diese wird in Abschnitt \ref{subsec:translate_type} behandelt.

Haben wir einen passenden Typen gefunden, müssen auch die Werte in einander überführt werden. Dies sollte eine bijektive Abbildung sein. Das dies nicht immer möglich ist, wird in Abschnitt \ref{sec:value-transformation} behandelt.

Für \lstinline!Float! und \lstinline!Double! ist der SL Typ \lstinline!Real! die semantisch beste Wahl. Im Ergebnis erhalten wir schematisch die SL-Funktion \lstinline!sl_foo! aus Listing \ref{lst:scala-fun-example-translate}.

\begin{lstlisting}[caption=Übersetzung von scala\_foo, label=lst:scala-fun-example-translate]
FUN sl_foo : Real -> Real
DEF sl_foo p0 = double_to_real (call_via_ajax (
                  scala_foo (real_to_float p0) 
                ) )
\end{lstlisting}

\section{Typübersetzung}
\label{sec:type-translation}

In den nächsten Abschnitten wird die Typübersetzung betrachtet. Also welche Scala Typen mit welchen SL Typen assoziiert werden. Dazu werden die beiden Typsysteme kurz erläutert und dann die Funktion $translate_{type}$ näher beschrieben.

\subsection{SL Typsystem}

Das Typsystem von SL ist besteht aus einer Reihe von vordefinierten Typen. Vordefiniert sind \lstinline!Int!, \lstinline!Real!, \lstinline!Char!, \lstinline!String!, \lstinline!Bool! und \lstinline!Void! sowie der Typ der \ac{JS}-Quoting Monade \lstinline!DOM a!.

Mit dem Stichwort \lstinline!DATA! können eigene Konstruktor-/Summentypen definiert werden \cite[S. 123]{Pepper2007}.

Bei Typdefinitionen werden Typen groß und Typvariablen klein geschrieben. Über Typvariablen können allgemeine Typen definiert werden, die für den Gebrauch spezialisiert werden. Mögliche Spezialisierungen für den Typ \lstinline!Either a b! wären zum Beispiel \lstinline!Either Int Real! oder \lstinline!Either Void String!.

\begin{lstlisting}[caption=Beispiele für selbst definierte Datentypen in \ac{SL}, label=lst:bsp2]
-- Summentyp
DATA Fruits = Apple | Orange | Plum

-- Konstruktortyp
DATA CycleKonst = Cycle Int Int

-- Mischung aus Konstruktor- und Summentyp mit Typvariablen
DATA Either a b = Left a | Right b
\end{lstlisting}

\subsection{Scala Typsystem}

Das Scala Typsystem in Gänze zu erklären würde den Rahmen dieser Arbeit bei weitem sprengen \cite{Odersky2013}. Im Rahmen dieser Arbeit wurden nur einige wenige vordefinierte Typen übersetzt.

Scala ist strikt Objektorientiert. Es kennt keine primitiven Typen. Alle Typen sind Objekte, aber es gibt vordefinierte Objekttypen die den primitiven Datentypen von Java zugeordnet werden können \cite{Paggen2013}. Im Folgenden werden die Typen \lstinline!Byte!, \lstinline!Short!, \lstinline!Int!, \lstinline!Long!, \lstinline!Float!, \lstinline!Double!, \lstinline!Boolean!, \lstinline!Char!, \lstinline!String! und \lstinline!Unit! trotzdem als die primitiven Typen von Scala bezeichnet. Die Vererbungshierarchie einiger vordefinierter Objekttypen kann dem Bild \ref{fig:classhierarchy} entnommen werden.

\begin{figure}[h] 
  \centering
     \includegraphics[width=\textwidth]{Bilder/classhierarchy}
  \caption{Vererbungshierarchie einiger Scala Klassen \cite{UnbekannterAutor2013}}
  \label{fig:classhierarchy}
\end{figure}

Es gibt in Scala-Konstrukte, die den selbst definierten Typen aus \ac{SL} sehr ähnlich sind. Das wird anschaulich am Beispiel von Option (siehe Listing \ref{lst:option-in-sl-scala}). Für sie kann die Übersetzung formalisiert werden. Mehr dazu im Abschnitt \ref{subsec:translate_type}. Es wurden aber auch andere Typen wie \lstinline!Seq[A]! übersetzt, deren innere Struktur sich stark von ihrem SL Äquivalent \lstinline!List a! unterscheiden.

\begin{lstlisting}[caption=Option in \ac{SL} und Scala, label=lst:option-in-sl-scala, float=h]
Option in SL:
PUBLIC DATA Option a = Some a | None

Option in Scala:
sealed abstract class Option[+A] ... { ... }

final case class Some[+A](x: A) extends Option[A] { ... }

case object None extends Option[Nothing] { ... }
\end{lstlisting}

\subsection{Funktion $translate_{type}$}
\label{subsec:translate_type}

%translate type formalisieren. möglich für option

Bei der Wahl eines SL Partnertyps für einen Scala Typ sollte auf zwei Bedingungen geachtet werden:

\begin{enumerate}
 \item{Die Typen sollten semantisch ähnlich sein.}
 \item{Es sollte eine semantisch sinnvolle bijektive Abbildung zwischen den Werten der beiden Typen existieren. }
\end{enumerate}

Wie wir im Abschnitt \ref{sec:value-transformation} sehen werden, wird die zweite Bedingung für einige primitiven Datentypen von Scala verletzt. Insbesondere für die ganzzahligen Primitiven kann sie nicht eingehalten werden. Da dadurch eine entsprechende Fehlerbehandlung unumgänglich wurde und um die Bedienung zu erleichtern wurden alle Fließkommaprimitiven von Scala mit \lstinline!Real! und die ganzzahligen Primitiven mit \lstinline!Int! assoziiert.

\begin{table}[h]
\caption{Die Funktion $translate_{type}$}
\centering
\begin{tabular}{l|llllllllllllll}
Scala Typ & Byte & Float & Char & Boolean & Unit & String & Seq[A] & Option[A]\\
 & Short & Double\\
 & Int\\
 & Long\\
SL Typ & Int & Real & Char & Bool & Void & String & List a & Option a\\
\end{tabular}
\label{tab:translate_type}
\end{table}


Bei generischen Datentypen wie \lstinline!Seq[A]! folgt aus den oben genannten Bedingungen, das die Anzahl der Typparameter der Partnertypen gleich sein sollte. Wenn ein generischer Datentyp übersetzt werden soll, wird versucht die Typparameter rekursiv zu übersetzen. Ist dies möglich kann auch der gesamte Typ übersetzt werden. Also \lstinline!Seq[Option[Long]]! würde zu \lstinline!List Option Int! übersetzt werden. Eine vollständige Auflistung von $translate_{type}$ findet sich in Tabelle \ref{tab:translate_type}.

\subsection{Formalisierung von $translate_{type}$}
\label{subsec:formal-translate-typ}

Bei primitiven Datentypen in Scala wurden ihre SL-Äquivalente durch ihre semantische Gleichheit vorgegeben (siehe Tabelle \ref{tab:translate_type}). 

Für bestimmte Typ-Konstrukte aus Scala kann die Übersetzung formalisiert werden. Sei dafür ein $Model$ durch folgende Grammatik beschrieben:

\begin{tabular}{lll}
\emph{Model} & ::= & \emph{Base} ; \emph{$Sub^+$}\\
\emph{Param} & ::= & \textbf{[ $\mathbf{V_1, \dots ,V_n}$ ]}\\
\emph{Base}  & ::= & \textbf{sealed abstract class} \emph{BaseName Param}\\
\emph{Sub}   & ::=   & \textbf{final case class} \emph{TypeName Param} \textbf{(} $Field^+$ \textbf{) extends} \emph{BaseName Param}\\
 & | & \textbf{case object} \emph{TypeName} \textbf{extends} \emph{BaseName} \textbf{[ Nothing$\,,\dots,\,$Nothing ]}\\
\emph{Field} & ::= & \emph{Name} \textbf{:} \emph{TypeName}\\
\\
\end{tabular}

Dabei sei $BaseName$ ein fester lokaler Typname, also alle Definitionen von $Sub$ erben von der gleichen abstrakten Klasse und $TypeName$ und $Name$ sind gültige Scala-Bezeichner. Damit wir diese Art von Klassen in einen SL-Typ übersetzen können, müssen alle Typvariablen die in den $Sub$ Definitionen benutzt werden bereits in der $Base$-Klasse definiert werden. Also $Param$ ist konstant für jede Instanz von $Model$.

Dann kann $translate_{type}$ folgendermaßen definiert werden, wobei = durch $\hat{=}$ ersetzt wird da es in SL Teil der Syntax ist:

\begin{centering}
$translate_{type}(Model)\:\hat{=}$\\
\textbf{DATA} $t_{Name}(BaseName)\:t_{Param}(Param)$ \textbf{=} $t_{Case}(Sub_1)$ \textbf{|} $\dots$ \textbf{|} $t_{Case}(Sub_n)$\\
\end{centering}

mit:

\begin{equation*}
t_{Param}( \textbf{[ } \mathbf{V_1, \dots, V_n} \textbf{ ]} )\:\hat{=}\: t_{TypVar}(\mathbf{V_1} ) \dots t_{TypVar}(\mathbf{V_n} )
\end{equation*}
\begin{gather*}
t_{Case}(\textbf{final case class }TypeName \: Param\:\textbf{(}\mathbf{N_1:T_1, \dots, N_n:T_n}\textbf{)} \textbf{ extends }\dots )\:\hat{=}\\t_{Name}(TypeName)\:t_{Type}(T_1) \dots t_{Type}(T_n)\\
t_{Case}(\textbf{case object } TypeName\textbf{ extends }BaseName\textbf{ [ Nothing}\, ,\dots,\,\textbf{Nothing ]})\:\hat{=}\\
t_{Name}(TypeName)
\end{gather*}
und
\begin{equation*}
t_{Type}(x)\:\hat{=} \begin{cases}
        t_{TypeVar}(x)  &|\, x \in \{V_1, \dots , V_n\}\\
        translate_{type}(x) &|\, \text{sonst}
        \end{cases}
\end{equation*}

Wobei $t_{Name}$ einem Scala-Bezeichner einen SL-konformen Bezeichner  und $t_{TypeVar}$ einer Typvariable eine eindeutige SL-konforme Typvariable zuordnet. Eine komplette Übersetztung ist nur möglich wenn $t_{Type}$ jedes $T_x$ übersetzen kann.

Dieses Schema wurde von einem Schema zum Übersetzen von \textbf{sealed trait}s im Paper von Höger et al.\cite{Hoger2013} inspiriert. Mit Hilfe dieser Schemata können einige der Scala-Typen in SL-Typen übersetzt werden. Wie man im Listing \ref{lst:option-in-sl-scala} sehen kann folgt die Definition von \lstinline!Option[A]! dem hier vorgestellten Schema. Die Definition von \lstinline!Option a! ist eine mögliche Lösung des Aufrufs von $translate_{type}$. Ein weiterer übersetzbarer Typ ist \lstinline!Either[A]!.

Im Rahmen dieser Arbeit wurden alle Übersetzungen händisch programmiert, da Typen der Standartbibliotheken von Scala und SL mit einander assoziiert wurden\footnote{Es wurden also keine Typen für SL zu Scala-Typen generiert. Da Klassenmethoden im Moment nicht automatisch übersetzt werden können, hätte man keine Funktionen die auf den generierten Typen opperieren.}. Es wurde sich aber bei einigen Typen an dem hier beschriebenen Schema orientiert. Bei anderen wie \lstinline!Seq[A]! war dies nicht möglich, da sich die innere Struktur von seinem SL-Äquivalent zu sehr unterscheidet.


\section{Darstellungsübersetzung}
\label{sec:value-transformation}

Wie bereits in der Einführung dieses Kapitels erwähnt, wählen wir die Wertübersetzungsfunktionen anhand des Scala Typs. Da SL nach JS kompiliert muss ein Scala Wert entsprechend seines Typs in eine passende JS Darstellung übersetzt werden. Für die Gegenrichtung, also SL nach Scala gilt dies analog. 

\subsection{Übersetzung von primitiven Werten}
\label{subsec:primitive-value-translation}

%TODO nochmal darauf verweisen welche primitive mit welchen primitiven assoziert sind | siehe translate_funktion dabei entsteht das problem der unterschiedlichen werte bereiche.
\begin{savenotes}
\begin{table}
\caption{Umfang der primitiven Datentypen in Scala und \ac{SL} (\ac{JS})\cite[S. 28-30]{Ecma2011}\cite{Oracle2011}}
\centering
\begin{tabular}{lll}
 \ac{SL} &    \ac{JS} Darstellung              &    Scala \\
\\
Int  &  Number\footnote{Alle Zahlendatentypen werden in \ac{JS} durch den primitiven Number Datentyp dargestellt. Dies ist eine Gleitkommazahldarstellung nach dem IEEE 754 Standard mit einer Breite von 64 Bit. In dieser Darstellung können Ganzzahlwerte von $-2^{53} + 1$ bis $2^{53} -1$ korrekt dargestellt werde.} $[-2^{53} + 1, 2^{53} -1]$   &  Byte  $[-128, 127]$\\
Int  &  Number $[-2^{53} + 1, 2^{53} -1]$   &  Short $[-2^{15}, 2^{15}-1]$\\
Int  & Number $[-2^{53} + 1, 2^{53} -1]$    & Int   $[-2^{31}, 2^{31}-1]$\\
Int  &  Number $[-2^{53} + 1, 2^{53} -1]$   &  Long  $[-2^{63}, 2^{63}-1]$\\
\\
Real &  Number (IEEE 754 64-Bit)      &  Float  (IEEE 754 32-Bit)\\
Real &  Number (IEEE 754 64-Bit)      &  Double (IEEE 754 64-Bit)\\
\\
Bool &  Boolean ${true, false}$         &  Boolean ${true, false}$\\
\\
Char &  String (Länge 1) (16-Bit)     &  Char (16-Bit)\\
\\
String& String\footnote{Die maximale Länge von Strings in \ac{JS} und Scala ist Implementationsabhängig.} (maximale Länge: ?)    &  String (maximale Länge: ?)\\
\end{tabular}
\label{tab:primitives-borders}
\end{table}
\end{savenotes}

Vor allem bei der Übersetzung von Primitiven existiert das Problem der unterschiedlichen Wertebereiche. Man kann zwar jeden Wert des Scala Typs \lstinline!Byte! in einen Wert des SL Typs \lstinline!Int! übersetzen, aber nicht umgekehrt. In der Tabelle \ref{tab:primitives-borders} werden die Wertebereiche für primitive Typen aufgelistet. Kann ein Wert von einer Darstellungsform nicht in die andere Darstellungsform umgewandelt werden muss dieser Fehler behandelt werden (siehe Abschnitt \ref{subsec:example-option-translator}). Insbesondere bei den ganzzahligen Primitiven ist das Problem unumgänglich.  Für ihre Wertebereiche gilt:

\begin{center}
$|$\lstinline!Int!$| < |$\lstinline!Number!$| < |$\lstinline!Long!$|$
\end{center}

\subsection{Übersetzung von komplexen Werten}

Bei nicht primitiven Werten ist mehr Aufwand nötig. Dafür müssen wir zunächst die JS-Darstellung von selbst definierten SL Typen verstehen\footnote{Das beschriebene Schema wurde aus dem SL Compiler generierten Code abgeleitet. Es ist nicht dokumentiert.}.

\begin{lstlisting}[caption=Beispiel eines selbstedefinierten Typs, label=lst:example-datatype-sl]
DATA People a b = Alice | Bob Int | Cesar a b | Octavian
\end{lstlisting}

Die einzelnen Konstruktoren erhalten entsprechend ihrer Reihenfolge eine Konstruktor-ID (\lstinline!_cid!) beginnend bei $0$. Hat ein Konstruktor keine Parameter, wird er nur durch seine \lstinline!_cid! dargestellt. Andernfalls wird ein Objekt erzeugt. Dies besitzt das Attribut \lstinline!_cid! sowie entsprechend der Anzahl der Parameter Attribute die von \lstinline!_var0! bis \lstinline!_varN! benannt sind. Die JS Darstellung von dem Beispieltyp aus Listing \ref{lst:example-datatype-sl} findet sich in der Tabelle \ref{tab:js-code-of-people}.

\begin{table}[h]
\caption{JS Darstellung des \ac{SL} Typen \lstinline!People Char Bool!}
\centering
\begin{tabular}{ll}
 \ac{SL}              &  \ac{JS} Darstellung \\
\lstinline!Alice!           &  \lstinline!0! \\
\lstinline!Bob 42!          &  \lstinline!{ "_cid" => 1, "_var0" => 42 }! \\
\lstinline!Cesar "a" true!  &  \lstinline!{ "_cid" => 2, "_var0" => "a", "_var1" => true }! \\
\lstinline!Octavian!        &  \lstinline!3! \\
\end{tabular}
\label{tab:js-code-of-people}
\end{table}

Mit Hilfe dieser Informationen und dem Schema aus Absatz \ref{subsec:formal-translate-typ} können jetzt Option-Werte zwischen SL und Scala ausgetauscht werden. In der Tabelle \ref{lst:option-in-sl-scala} wurden beispielhaft einige Werte vom Typ \lstinline!Option[Int]! übersetzt. In Abschnitt \ref{subsec:example-option-translator} wird auf die Implementation der Übersetzung noch einmal genauer eingegangen.

\begin{table}[h]
\caption{Übersetzung von Option Werten}
\centering
\begin{tabular}{lll}
Scala                   & \ac{JS} Darstellung                        & SL \\

\lstinline!Option[Int]! &                                            & \lstinline!Option Int! \\

\lstinline!Some(15)!    & \lstinline!{ "_cid" => 0, "_var0" => 15 }! & \lstinline!Some(15)! \\
\lstinline!None!        & \lstinline!1!                              &  \lstinline!None! \\
\end{tabular}
\end{table}

Die Übersetzung von anonymen Funktionen also Werten die eine Funktion darstellen ist im Moment nicht möglich, da kein adäquater Weg gefunden wurde um ihre Darstellung zwischen Scala und JS aus zu tauschen.

%TODO vllt noch Seq[A] zu List a erklären

\section{Erleuterung der Implementation}
\label{sec:trans-implementation}

In der momentanen Implementation wird $translate_{type}$ durch \lstinline!Seq[AbstractTranslator]! dargestellt. Dadurch ist es möglich auch Teilmengen von $translate_{type}$ zu benutzen. Dabei stellt eine Klasse die von \lstinline!AbstractTranslator! erbt ein Paar zwischen einem Scala-Typ und einem SL-Typ dar. Die Klasse ist nach dem jeweiligen Scala Typen den sie übersetzt benannt\footnote{zB. \lstinline!SeqTranslator!}. Die Hauptmethode von \lstinline!AbstractTranslator! ist \lstinline!translate! (siehe Listing \ref{lst:main-function-translate}). Ihr wird ein Scala Typ übergeben. Wenn der übergebene Scala Typ der Klasse entspricht erhält man als Rückgabewert den entsprechenden \ac{SL} Typen, die Import Statements um die entsprechenden \ac{SL} Module zu laden\footnote{Bei primitiven \ac{SL} Typen sind diese leer. Für den \ac{SL} Typ \lstinline!List.List Opt.Option Int! würde \lstinline!IMPORT "std/option" AS Opt, IMPORT "std/list" AS List! zurück gegeben werden.} sowie die \ac{AST}-Repräsentation der Wertübersetzungsfunktionen von Scala nach \ac{SL} und umgekehrt. Andernfalls wird \lstinline!None! zurückgegeben.

\begin{lstlisting}[caption=Hauptfunktion in AbstractTranslator, label=lst:main-function-translate]
def translate
  ( context: MacroCtxt )
  ( input: context.universe.Type, translators: Seq[AbstractTranslator] )
: Option[( String, 
           Set[String], 
           context.Expr[Any => JValue], 
           context.Expr[JValue => Any] )]
\end{lstlisting}

Weiter Parameter sind \lstinline!context! und \lstinline!translators!. \lstinline!context! ist der Makro Kontext\footnote{siehe Kapitel \ref{chap:scala-compiler-macros}}. Er wird benötigt um \ac{AST}s aufzubauen und den übergebenen Typen zu prüfen. Mit \lstinline!translators! wird der Teil von $translate_{type}$ übergeben mit denen Spezialisierungen eines generischen Typs übersetzt werden können.

Möchte man einen Scala Typ nicht nur gegen eine Klasse prüfen kann man die Hilfsfunktion \lstinline!useTranslators! aus dem companion object von \lstinline!AbstractTranslator! nutzen.

\begin{lstlisting}[caption=Statische Hilfsfunktion in AbstractTranslator, label=lst:hilfsfunktionen]
def useTranslators
  ( context: MacroCtxt )
  ( input: context.universe.Type, translators: Seq[AbstractTranslator] )
: Option[( String,
           Set[String], 
           context.Expr[Any => JValue], 
           context.Expr[JValue => Any] )]
\end{lstlisting}

\lstinline!translators! gibt hier an welche Teilmenge der Funktion $translate_{type}$ man nutzen möchte\footnote{\lstinline!translators! wird in diesem Fall auch für die Spezialisierungen von generischen Typen benutzt.}. 

Die Wertübersetzungsfunktionen haben die Signatur \lstinline!Any => JValue! bzw. \lstinline!JValue => Any!. \lstinline!JValue! ist Teil der json4s Bibliothek \cite{Json4s}, die benutzt wird um JS-Werte zu erzeugen. Insbesondere übernimmt sie in der aktuellen Implementation die Übersetzung der primitiven Werte.

\subsection{OptionTranslator als Beispiel}
\label{subsec:example-option-translator}

Der \lstinline!OptionTranslator! bildet die Verbindung zwischen dem Scala-Typ \lstinline!Option[A]! und seinem SL-Pendant \lstinline!Option a! ab. 

Wie bereits erwähnt ist die Hauptfunktion \lstinline!translate! (siehe Listing \ref{lst:main-function-translate}). In ihr wird zunächst mit reflection überprüft ob der übergebene Typ (\lstinline!input!) ein Subtyp von \lstinline!Option[Any]! ist. Durch die Definition von \lstinline!Option[A]! (\lstinline!sealed! und \lstinline!final case! siehe Listing \ref{lst:option-in-sl-scala}) können wir uns sicher sein, das übergebenen Werte nur vom Typ \lstinline!Some[A]! oder \lstinline!None! sind. Wieder mit reflections wird der Typ der Spezialisierung \lstinline!A! bestimmt. Ist dieser Typ mit Hilfe der übergebenen Translator-Klassen (\lstinline!translators!) übersetzbar, wird das Ergebnis zusammengestellt. In jedem anderen Fall wird \lstinline!None! zurückgegeben.

Das Ergebnis besteht aus dem SL-Typ (zB. \lstinline!Option Int!), der Import-Anweisung (zB. \lstinline!IMPORT "std/option" AS Opt!) und den ASTs der beiden Wertübersetzungsfunktionen. Die Wertübersetzungsfunktionen werden im companion object definiert um sie besser mit Unit-Tests zu testen. Mit Hilfe der Funktion \lstinline!reify! aus der Makro API von Scala wird aus Scala-Code der entsprechende AST generiert. Grundsätzlich könnte der AST auch eine anonyme Funktion und keine Funktionsaufruf repräsentieren die Wertübersetzung beschreibt. In späteren Kapiteln heißen die Funktionen zum Übersetzen deshalb immer \lstinline!scala_to_js! und \lstinline!js_to_scala!.

\begin{lstlisting}
reify ( {
( i : Any ) = > OptionTranslator.scalaToJsOption ( i , expr_s2j )
} )
\end{lstlisting}

\lstinline!expr_s2j! ist in diesem Fall die Wertübersetzungsfunktion des Typs der Spezialisierung. 

\begin{lstlisting}
def scalaToJsOption( input: Any, f: Any => JValue ): JValue = {
  import org.json4s._
  input match {
    case Some( x ) => {
      val tmp: List[( String, JValue )] = 
        List( "_cid" -> JInt( 0 ), "_var0" -> f( x ) )
      JObject( tmp )
    }
    case None => JInt( 1 )
    case _ => throw new IllegalArgumentException
  }
}
\end{lstlisting}

Wird an die Wertübersetzungsfunktion ein unerwarteter Wert (oder bei primitiven Typen ein Wert außerhalb der zulässigen Grenzen) übergeben wird eine \lstinline!IllegalArgumentException! geworfen.

Möchte man einen einen neuen Scala-Typ übersetzen bzw. zu $translate_{type}$ hinzufügen muss eine neue Translator-Klasse geschrieben werden. Eine entsprechende Anleitung findet sich im Anhang \ref{sec:new-translator-class}.

\chapter{Scala Compiler Macros}
\label{chap:scala-compiler-macros}

Im \ref{cha:sl-introduction}. Kapitel wurde SL vorgestellt. Eine strikt getypte funktionale Sprache die in JS-Code übersetzt wird.

SL brachte Höger et al. auf die Idee mit Hilfe von Scala Compiler Makros eine strikt getypte Abstraktion für JS in Scala einzubinden\cite{Hoger2013}. Um ihre Ergebnisse zu demonstrieren haben sie eine Beispielwebanwendung mit Hilfe des Play-Frameworks\cite{Play1} geschrieben. 

Play ist ein \ac{MVC}-Framework für Webanwendungen welches in Scala geschrieben ist. Play vereinfacht die Erstellung von strukturierten Webanwendungen. Auch innerhalb dieser Arbeit wird es genutzt, um die Einbettung von SL in Scala zu erproben.

Es konnte das Problem der dynamischen Typisierung von JS behoben werden, aber ein anderes blieb offen. Bis jetzt war es nicht möglich SL- bzw. JS-Code abhängig von der Scala-Umgebung zu generieren. Insbesondere für Webanwendung stellt dies ein Problem dar. Es sollte möglich sein den JS-Code zum Beispiel mit dem Benutzername zu personalisieren. 

Mit Hilfe der im Kapitel \ref{cha:model-sharing} beschriebenen Einbettung von Scala-Werten/-Typen in SL ist es jetzt möglich dieses Problem zu lösen.

Um den SL-Code von der Scala-Umgebung abhängig zu machen wurden zwei Ansätze verfolgt. Zum einen ist es jetzt möglich Scala-Werte direkt im SL-Code zu nutzen. Dazu werden Platzhalter in den SL-Code eingefügt die dann durch übersetzte Scala-Werte ersetzt werden.

Auf der anderen Seite können aus Scala-Funktionen aus SL-Code heraus aufgerufen werden. Dazu wird aus einer Scala-Funktion eine SL-Funktion generiert, die die Scala-Funktion über asynchrone Kommunikation mit dem Server und Scala reflections aufruft.

Um diese Lösungen zu realisieren wurden zwei Scala Compiler Makros geschrieben. Diese werden im Laufe dieses Kapitels vorgestellt.

\section{Makros und ihre Abhängigkeiten}
\label{sec:project-structure}

Um Scala Funktionen für die Verwendung in \ac{SL}-Code zu markieren wurde die macro annotation \lstinline!sl_function! geschrieben, welche im Abschnitt \ref{sec:annotation-macro} behandelt wird. Im darauf folgenden Abschnitt \ref{sec:inline-macro} wird beschrieben, wie statischer \ac{SL} Code mit Hilfe des def macros \lstinline!slci! eingebunden wird und welchen Veränderungen gemacht werden mussten um Scala Werte und annotierte Funktionen benutzen zu können. Beide Makros binden den Trait \lstinline!MacroConfig! ein, in dem grundsätzliche Konfigurationen definiert sind. Zur Übersetzung der Typen und Werte werden die Translator-Klassen genutzt. Einen Überblick über das Projekt bietet die Abbildung \ref{fig:project-overview}.

\begin{figure}[h] 
  \centering
     \includegraphics[width=\textwidth]{Bilder/projektstruktur}
  \caption{Projektübersicht}
  \label{fig:project-overview}
\end{figure}

\subsection{Konfiguration der Makros}
\label{subsec:macro-config}

Im Trait \lstinline!MacroConfig! werden die beiden hier programmierten Makros konfiguriert. In den anschließenden Abschnitten wird sich darauf bezogen. Die wichtigsten Konfigurationsparameter sind:

\begin{description}
 \item[assets\_dir] Gibt an in welchem Ordner die SL-Quelldateien und ihre Kompilate liegen. Im Moment \lstinline!/projekt_ordner/public/sl/!.
 \item[inline\_sl\_macro\_folder] Gibt den Unterordner von \lstinline!assets_dir! an, in dem die SL-Module/-Quelldateien und ihre Kompilate liegen, die vom def marco slci generiert werden. Im Moment: \lstinline!generated_inline/!.
 \item[annotation\_sl\_macro\_folder] Gibt den Unterordner von \lstinline!assets_dir! an, in dem die SL-Module, die von der macro annotation sl\_function generiert werden, liegen. Im Moment: \lstinline!gnerated_annotation/!.
 \item[inline\_sl\_macro\_handler\_uri] Gibt die \ac{URL} an unter welcher der Server auf asynchrone Kommunikation lauscht um per reflection annotierte Scala-Funktionen aufzurufen. Im Moment ist dies eine relative \ac{URL}: \lstinline!/ajax!.
\end{description}

Wird in der Konfiguration etwas geändert muss das ganze Projekt neu kompiliert werden. Insbesondere müssen alle generierten SL-Module neu erstellt werden.

%TODO Probleme mit namen von scala funktionen

\section{Macro Annotation sl\_function }
\label{sec:annotation-macro}

Mit macro annotations kann in den Übersetzungsprozess von Scala eingegriffen werden\cite{EPFL1}. Es ist möglich den annotierten Code zu verändern\footnote{Es können Funktionen, Klassen, Objekte, Typparameter oder Funktionsparameter annotiert werden.}. Mit dem geschriebenen Makro können nur Funktionen annotiert werden. Für jede Funktion wird eine Hilfsfunktion und ein \ac{SL}-Modul erzeugt. Die Hilfsfunktion soll den Aufruf im Rahmen von ajax requests erleichtern. Das \ac{SL}-Modul ermöglicht es diesen Aufruf typsicher in \ac{SL}-Programme einzubinden. Beispielhaft wird das An­no­tie­ren einer Funktion anhand der im Listing \ref{lst:example-function} beschriebenen Funktion \lstinline!factorial! betrachtet.


\begin{lstlisting}[caption=Scala Beispielfunktion, label=lst:example-function, float=h]
-- Foo.scala
package example

object Foo {
  @sl_function def factorial( i: Int ): Long = {...}
}
\end{lstlisting}

\subsection{Anforderungen an eine Funktion}

Die zu übersetzende Funktion muss gewisse Anforderungen erfüllen. Wenn wir sie im Rahmen von ajax requests benutzen wollen, muss sie statisch aufrufbar sein, also:
\begin{itemize}
  \item[-]{Sie muss in einem Objekt definiert sein.}
  \item[-]{Ihre Signatur darf keine Typparameter enthalten.}
  \item[-]{Die Funktion darf nicht als \lstinline!private! oder \lstinline!protected! markiert sein.}
 \end{itemize}

Andere Anforderungen ergeben sich aus der Implementation bzw. wurden aufgestellt um die Implementation zu erleichtern:

\begin{description}
 \item[Die Ein- und Ausgangstypen müssen sich in SL-Typen übersetzen lassen.]{Gilt dies nicht kann keine passende SL-Funktion erzeugt werden.}
 \item[Die Funktion muss einen Rückgabetyp definieren.]{Andernfalls müsste der Rückgabetyp erst über reflection bestimmt werden. Der Scala Compiler kann den Rückgabetyp wahrscheinlich bestimmen, dies wurde aber nicht in Angriff genommen.}
 \item[Die Funktion darf nur eine Parameterliste haben.]{Mehrere Parameterlisten könnten in eine zusammengefasst werden. Da diese Einschränkung aber nur minimal ist und es den Aufruf der Funktion über reflection erschwert wurde davon Abstand genommen.}
 \item[Standardwerte von Parametern werden ignoriert.]{In der aktuellen Implementation werden die Standardwerte eines Parameters ignoriert. Eine entsprechende Compilerwarnung wird erzeugt.}
 \item[Der Funktionsname darf keine ungewöhnlichen Zeichen enthalten]{Da sich der Name der Funktion im Name und Pfad des erzeugten Moduls widerspiegelt, sind nur die Zahlen von 0 bis 9 sowie kleine Buchstaben von a bis z erlaubt. Ähnliche Einschränkungen gelten für die übergeordneten Pakete sowie den Namen des Objekts in dem die Funktion definiert ist.}
\end{description}

\subsection{SL-Modul}
\label{subsec:sl-modul}

Für jede annotierte Funktion wird ein Modul erstellt. Das heißt eine SL-Quelldatei erstellt, die den entsprechenden SL-Code enthält.

Das Modul enthält zwei Funktionen. Jeweils für den asynchronen und synchronen Aufruf der Scala-Funktion über Ajax. Das Ergebnis wird in \lstinline!Option! gekapselt, um auf Fehler in der Kommunikation mit dem Server reagieren zu können. Das Erzeugen der Ajax Anfrage und das Behandeln des Ergebnisses passiert in den \ac{JS}-Funktionen \lstinline!_sendRequestSync()! und \lstinline!sendRequestAsync()!. Diese Funktionen sind in der \ac{JS}-Bibliothek std/\_scalafun.js definiert. 

Weiterhin enthält das Modul in Kommentaren den Namen der aufgerufenen Funktion sowie den voll qualifizierten Namen des Objektes in dem die Funktion definiert ist. Diese Informationen werden gebraucht um Abhängigkeiten zwischen der Scala Funktion und ihrer Benutzung in \ac{SL}-Code aufzulösen. Genauer wird dies im Abschnitt \ref{subsec:use-scala-function-in-sl} beschrieben. Das Modul wird direkt nach dem erstellen kompiliert.

Zu erwähnen sind noch die Import-Anweisungen. Die Quelldateien \lstinline!std/option! und \lstinline!std_scalafun! werden immer importiert, da sie offensichtlich immer gebraucht werden. Enthält aber die Funktionsdefinition der annotierten Funktion einen Scala-Typ dessen SL-Pendant in einem externen Modul definiert ist (zum Beispiel \lstinline!List a!) muss dieses auch importiert werden. Eine entsprechende Import-Anweisung wird dann hinzugefügt.

\begin{lstlisting}[caption=SL-Modul factorial.sl zur Funktion aus Listing \ref{lst:example-function}, label=lst:example-sl-modul, float=h]
-- DO NOT ALTER THIS FILE! --------------------------------
-- cp: example.Foo
-- fn: factorial
-- --------------------------------------------------------
-- this file was generated by @sl_function macro ----------
-- on 20-06-2014 ------------------------------------------
IMPORT EXTERN "std/_scalafun"
IMPORT "std/option" AS Opt

-- this functions should call the scala function:
-- example.Foo.factorial
PUBLIC FUN factorialSync : Int ->  DOM ( Opt.Option (Int) )
DEF factorialSync p0 = {| _sendRequestSync( ... ) ($p0) |}  : DOM ( Opt.Option (Int) )

PUBLIC FUN factorialAsync : ( Opt.Option (Int) -> DOM Void )  -> Int -> DOM Void
DEF factorialAsync callbackFun p0 = {| _sendRequestAsync( ... )  ($callbackFun, $p0) |} : DOM Void
\end{lstlisting}

\subsection{Hilfsfunktion}
\label{subsec:helperfunction}

Um den Aufruf mit Ajax Anfragen zu erleichtern wird eine Hilfsfunktion definiert. Sie kapselt die eigentliche Scala Funktion. Sie erhält die Parameter als \lstinline!JValue!. Die Parameter werden mit Hilfe der Funktionen aus den Translator Klassen in Scala Werte übertragen und dann auf die passenden Typ gecasted. Anschließend wird mit ihnen die eigentlich Funktion aufgerufen. Das Ergebnis wird in ein \lstinline!JValue! Wert umgewandelt und zurückgegeben.

Die Funktionen \lstinline!scala_to_sl! und \lstinline!sl_to_scala! sind nur Platzhalter. Wie diese Funktionen genau definiert sind, hängt von der Implementation der entsprechenden Translator-Klasse ab (siehe Abschnitt \ref{subsec:example-option-translator}).

\begin{lstlisting}[caption=Hilfsfunktion zur Funktion aus Listing \ref{lst:example-function}, label=lst:helperfunction, float=h]
-- Foo.scala
package example

object Foo {
  @sl_function def factorial( i: Int ): Long = {...}
  
  def factorial_sl_helper( p1: org.json4s.JValue ) : org.json4s.JValue = {
    scala_to_sl(factorial(sl_to_scala(p1)))
  }
}
\end{lstlisting}

\subsection{Ablauf eines sl\_function Aufrufs}

Wie bereits erwähnt wird das Makro während der Übersetzung des Scala Programms aufgerufen. Der Aufruf des sl\_function folgt den letzten drei Abschnitten. Zunächst wird überprüft ob die annotierte Funktion den Anforderungen genügt. Dann wird das Modul im Ordner \lstinline!annotation_sl_macro_folder! (siehe Abschnitt \ref{subsec:macro-config}) erzeugt und übersetzt. Der genaue Pfad des Moduls ist \lstinline!annotation_sl_macro_folder/!

 Daraufhin wird der \ac{AST} der Hilfsfunktion erzeugt und diese hinter der annotierten Funktion in das Objekt eingefügt. 

Sollte es in einem der Schritte zu einem Fehler kommen, wird ein Compilerfehler erzeugt und die Übersetzung des Scala Programms abgebrochen.

%TODO ordnerstruktur erklären

\subsection{Ablauf eines Aufrufs}
\label{subs:call-scala-functions}

Betrachten wir nun den Aufrufprozess einer Funktion im Ganzen am Beispiel der Funktion \lstinline!factorialSync! aus dem Listing \ref{lst:example-sl-modul}. Folgende Schritte werden durchlaufen:
\begin{enumerate}
 \item{Aufruf der Funktion \lstinline!factorialSync 5! im \ac{SL}-Code}
 \item{Aufruf der \ac{JS}-Funktion \lstinline!(_sendRequstSync( "\ajax", "example.Foo", "factorial" )) (5)!. Es werden der \ac{URL} des Ajax-Handlers, der voll qualifizierte Name des Objekts und der Funktionsname übergeben. In einem zweiten Schritt wird der eigentliche Parameter (\ac{SL}-Codiert) übergeben.}
 \item{Die \ac{SL}-Parameter werden mit Hilfe der Bibliothek json.js \cite{Crockford2010} in einen JSON String umgewandelt und mit Funktions- und Objektname als Anfrage an die Adresse des Ajax-Handlers geschickt (siehe Tabelle \ref{tab:post-parameter}).}
 \item{Der Ajax-Handler wandelt die Funktionsparameter (\lstinline!5!) in \lstinline!JValue! Werte um \cite{Json4s} und ruft dann über reflection die Hilfsfunktion \lstinline!factorial_sl_helper! auf. Das Ergebnis (\lstinline!120!) des Aufrufs wird als JSON String zurück an den Client gesendet.}
 \item{Ist die Anfrage an den Server erfolgreich wird \lstinline!Some(120)! zurückgegeben, andernfalls \lstinline!None!.}
\end{enumerate}

\begin{table}[h]
\caption{Post Parameter der Ajax Anfrage}
\centering
\begin{tabular}{ll}
Parametername        &   Inhalt \\
\hline
object\_name   & Voll qualifizierter name des Objekts \\
function\_name & Name der Funktion\\
params         & JSON encodierte Liste der übergebenen Parameter\\
\end{tabular}
\label{tab:post-parameter}
\end{table}

\section{Def Macro slci}
\label{sec:inline-macro}

%TODO erwähnen das es komplett neu geschrieben wurde

Bis jetzt kann man nur Funktionen markieren. Nun soll \ac{SL} benutzt werden um \ac{JS}-Code zu generieren und ihn auf Benutzerseite zu verwenden. Dazu wurde das \lstinline!slci! Makro neu geschrieben und erweitert. Im Laufe der nächsten Abschnitte vollziehen wir die Entwicklungsschritte des Makros nach.

Mit def macros kann während des Übersetzungsprozesses von Scala in den Code eingegriffen werden \cite{EPFL2}. Der Aufruf solch eines Makros verhält sich wie eine Funktion, nur das das Makro die \ac{AST}s der Parameter übergeben bekommt und einen \ac{AST} liefert der den Aufruf des Makros ersetzt. Listing \ref{lst:slci-example} enthält einen beispielhaften Aufruf des slci-Makros.

\begin{lstlisting}[caption={Beispielaufruf des slci-Makros in einer Play View}, label=lst:slci-example, float=h]
-- Example.scala.html
...
<script type="text/javascript">@{
Html(slci(
"""
PUBLIC FUN main : DOM Void
DEF main = ...
"""
))}
</script>
...
\end{lstlisting}

\subsection{Statischen SL Code übersetzen}
\label{subsec:compile-static-sl}

Mit der Entwicklung eines Modulsystems für \ac{SL} musste das Einbetten von statischem Code neu geschrieben werden \cite{Bisping2013}. Die erste Version des \lstinline!slci! Makros nutzte eine Version von \ac{SL} die \ac{JS} Code erzeugt. Im Laufe des Studentenprojekts wurde davon Abstand genommen. Das Ergebnis der Übersetzung sind \ac{JS}-Dateien, die mit Hilfe von require.js in Webseiten eingebettet werden \cite{RequireJS1}.

%TODO kurz beschreiben was require.js ist

Entsprechend wird jetzt vom \lstinline!slci! Makro ein \ac{SL}-Modul erzeugt. Die Datei wird entsprechend des Ortes an dem \lstinline!slci! aufgerufen wird benannt:
\begin{center}
\lstinline!<Dateiname>.<Zeilennummer>.sl!
\end{center}
Wenn diese Datei übersetzt werden kann, wird sie mit require.js eingebunden, dass dann die main-Funktion des Moduls aufruft. Andernfalls wird ein Übersetzerfehler erzeugt. 

Neben require.js müssen noch andere \ac{JS}-Bibliotheken geladen werden. Möchte man \ac{SL}-Code in einer Webseite benutzen, müssen alle Bibliotheken, die in Tabelle \ref{tab:js-libraries} aufgelistet sind, eingebunden werden.

\begin{table}[h]
\caption{Benötigte \ac{JS}-Bibliotheken}
\centering
\begin{tabular}{ll}
jquery-1.9.0.min.js & Erleichtert Ajax-Anfragen. Wird vom sl\_function-Markro benötigt\cite{JQuery1}.\\
sl\_init.js         & Initialisiert die globale Variable \lstinline!sl! und konfiguriert require.js. \\
                    & Muss vor require.js geladen werden.\\
require.js          & Wird benötigt um \ac{SL}-Module nach zu laden\cite{RequireJS1}.\\
json.js             & zum Umwandeln von JS Werten in ihre JSON-Repräsentation \\
                    & und zurück. Siehe Abschnitt \ref{subs:call-scala-functions}\cite{Crockford2010}.\\
\end{tabular}
\label{tab:js-libraries}
\end{table}

\subsection{Scala Variablen in SL nutzen}

Als nächstes wurde die Verwendung von Scala-Variablen in \ac{SL}-Code implementiert. Anhand des Beispiels im Listing \ref{lst:slci-example-var} werden die dafür nötigen Schritte erklärt.

\begin{lstlisting}[caption={Beispielaufruf des slci Macros mit Scala Variablen}, label=lst:slci-example-var, float=h]
slci(
"""
IMPORT "std/option" AS Option 
...
FUN foo : Option.Option Int
DEF foo = $s
...
""",
Some(3)
)
\end{lstlisting}

Die zu ersetzende Stelle wird durch einen Platzhalter (\lstinline!$s!) markiert. Der $n+1$-te Parameter von \lstinline!slci! wird dem $n$-ten Platzhalter zugeordnet. Falls die Anzahl der Parameter ungleich der Anzahl der Platzhalter ist, werden Warnings oder Errors erzeugt. 

Daraufhin werden die \lstinline!IMPORT!-Anweisungen analysiert und die entsprechenden Translator-Klassen geladen\footnote{Translator-Klassen die in Standardtypen von SL übersetzen, werden immer geladen. Für \lstinline!IMPORT "std/option" AS Modulalias! würde die Instanz \lstinline!new OptionTranslator("Modulalias")! erzeugt werden.}. Die von der Makro-API bestimmten Typen\footnote{Manchmal muss man den Typ annotieren. Das Literal \lstinline!5! hat den Typ \lstinline!Int(5)! und nicht \lstinline!Int!. Man schreibt also \lstinline!5:Int!.} der Parameter werden dann mit den zur Verfügung stehenden Translator-Klassen übersetzt. 
Wenn alle Typen übersetzt werden konnten, werden die Platzhalter durch \ac{JS}-Quotings ersetzt, die auf globale Variablen zugreifen. Im Beispiel aus Listing \ref{lst:slci-example-var} würde \lstinline!$s! durch \lstinline!{| sl['5a40c735438fd9e1fd43657bd7f8564scalaParam1'] |} : Option.Option Int!\footnote{Der Name der JS-Variable folgt folgendem Schema: \lstinline!<Hash des Macrokontexts>scalaParam<Parameternummer>!.} ersetzt werden. Der so erzeugte SL-Code wird dann, wie im Abschnitt \ref{subsec:compile-static-sl} beschrieben, übersetzt. 
Listing \ref{lst:slci-example-var-scala-code} enthält den vom Makro erzeugt Scala-Code. 

\begin{lstlisting}[caption={Erzeugter Scala-Code zum Listing \ref{lst:slci-example-var}}, label=lst:slci-example-var-scala-code, float=h]
{ 
"""
require(...);
// transformed scala variables    
sl['5a40c735438fd9e1fd43657bd7f8564scalaParam1'] = %s;
""".format( compact( render( scala_to_sl( Some(3) ) ) ) )
}
\end{lstlisting}

Die Parameter werden, mit den von den Translator-Klassen erzeugten Übersetzungsfunktionen, in \ac{SL}-Werte übersetzt. Da sie zuerst als \lstinline!JValue!-Objekte vorliegen müssen sie noch in \ac{JS}-Code überführt werden. Im Listing \ref{lst:slci-example-var-js-code} findet sich der nach einem Aufruf der Webseite erzeugte \ac{JS}-Code.

\begin{lstlisting}[caption={JS-Code zum Listing \ref{lst:slci-example-var}}, label=lst:slci-example-var-js-code, float=h]
require( 
  [ "generated_inline/example.template.scala.48.sl" ],
  function (tmp) { sl['koch.template.scala.1'] = tmp; }
);
// transformed scala variables 
sl['5a40c735438fd9e1fd43657bd7f8564scalaParam1'] = {"_cid":0,"_var0":3};
\end{lstlisting}

\subsection{Scala Funktionen in SL nutzen}
\label{subsec:use-scala-function-in-sl}

Im Abschnitt \ref{sec:annotation-macro} wurde erklärt wie Scala-Funktionen für die Verwendung in \ac{SL}-Code markiert werden. Für die markierten Funktionen werden \ac{SL}-Module erzeugt. Wenn ein solches Modul geladen wird\footnote{Der Pfad des Moduls fängt in der aktuellen Konfiguration mit \lstinline!generated_annotation/! an.}, werden am Anfang des vom Makro erzeugten Scala-Codes \lstinline!import!-Anweisungen eingefügt, die auf die referenzierten Scala Funktionen verweisen. Falls sich die Signatur der importierten Funktionen ändert, soll der Aufrufende SL-Code neu compiliert werden.
Für die Funktion \lstinline!factorial! aus Listing \ref{lst:example-function} würde der Scala-Code im Listing \ref{lst:slci-function-import} erzeugt werden.

\begin{lstlisting}[caption={Scala \lstinline!import!-Anweisung für eine annotierte Funktion}, label=lst:slci-function-import, float=h]
{
import example.Foo.{factorial => fun3903232409}
"""
require(...);
...
""".format( ... )
}
\end{lstlisting}

Die Funktion wird unter einem zufallsgenerierten Namen importiert um Namenskonflikten vorzubeugen.

%TODO kapitel umbennene hier sollte der sl compiler vorgestellt und seine erweiterungen im rahmen dieser arbeit beschrieben werden.
\chapter{Erweiterungen am SL-Compiler}
\label{chap:dom-monad-extensions}

Im Laufe der Diplomarbeit wurde der \ac{SL}-Compiler an einigen Stellen erweitert oder verändert. Die Compilermakros verwenden den im Studierendenprojekt geschriebenen \lstinline!MultiDriver! \cite[S. 16-19]{Bisping2013}. 

\section{Erweiterungen am MultiDriver}

In der vorherigen Version des \lstinline!MultiDriver!s wurden, wenn ein Modul eine main-Funktion enthält, neben dem Kompilat die Dateien \lstinline!main.js! und \lstinline!index.html! erstellt \cite[S. 18-19]{Bisping2013}. Da dies unerwünscht ist, wenn der \ac{SL}-Code in eine Play View eingebettet wird, wurde in der Konfiguration (\lstinline!Configs.scala!) des Compilers eine neue Option eingeführt. Mit dem Schalter \lstinline!generate_index_html! kann das oben genannte Verhalten unterdrückt werden. Im Normalfall ist dieser Wert auf \lstinline!true! gesetzt; die Makros verwenden ihn mit dem Wert \lstinline!false!.

Die übersetzten Bibliotheksmodule (zum Beispiel: option.sl.js) werden in das Zielverzeichnis der Übersetzung kopiert, wenn das zu übersetzende Modul eine main-Funktion enthält und der SL-Übersetzer in Form einer jar-Datei vorliegt. Das ist nötig, damit die entsprechenden Module nachgeladen werden können. Dies ist bis jetzt undokumentiertes Verhalten. In der aktuellen Version des SL-Übersetzers werden die Dateien auch kopiert wenn der Übersetzer nicht gepackt vorliegt.

Weiterhin wurde der Schalter \lstinline!main_function_is_required! eingeführt. Wenn dieser Wert auf \lstinline!true! gesetzt ist, wird sichergestellt das ein zu übersetzendes Modul eine main-Funktion enthält. Falls dies nicht der Fall ist wird die Übersetzung mit einem Fehler abgebrochen. Wie im Abschnitt \ref{subsec:compile-static-sl} beschrieben, ist für das slci-Makro eine main-Funktion nötig. Der Standardwert des Schalters ist \lstinline!false!.

\section{Überprüfung des Ergebnistyps von \ac{JS}-Quotings}

Mit JS-Quotings kann JS-Code direkt in SL benutzt werden. Bis jetzt wurde das Ergebnis solcher Quotings zur Laufzeit nicht auf Korrektheit überprüft \cite[S. 29]{Bisping2013}. Im Rahmen dieser Arbeit wurde dieses Verhalten für einige primitive Typen (\lstinline!String!, \lstinline!Char!, \lstinline!Bool!, \lstinline!Real! und \lstinline!Int!) geändert. Dies gilt nur für JS-Quotings die einen entsprechenden \lstinline!DOM a!-Typen haben, wie zum Beispiel im Listing \ref{lst:exampl-js-quoting}.

\begin{lstlisting}[caption={Beispiel: JS-Quoting Monade}, label=lst:exampl-js-quoting]
FUN foo : DOM Int
DEF foo = {| document.getElementById("canvas").width |}:DOM Int
\end{lstlisting}

Passt das Ergebnis nicht zum Typ wird die Ausführung des Programms mit einer Exception abgebrochen.

\chapter{Related Works}
\label{chap:related-works}

Auch andere Gruppen haben JS in Scala eingebunden. In den folgenden Abschnitten wird versucht einen groben Überblick dazu zu geben und sie mit der hier vorgestellten Implementation zu vergleichen. 

Allen Ansätzen ist gemein, das sie JS zu einem statischen Typsystem verhelfen. Was die Wartung großer Projekte in JS erleichtert. 

\section{Scala.js}
\label{sec:scala-js}

Scala.js ist ein Compiler. Er übersetzt Scala Code in JS anstatt in JVM Bytecode\cite{Doeraene2013}. Der Compiler wurde als Compiler-PlugIn für den Scala Standardcompiler geschrieben und kann damit auch Eigenschaften wie Compilermakros nutzen. 

Mit Scala.js kann die gesamte Sprachkern von Scala sowie einige wenige Teile des Javasprachkerns, die essenziell für Scala sind, genutzt werden. Es gibt leichte Unterscheide, da sich die primitiven Datentypen in Scala und JS unterschiedlich verhalten (siehe Abschnitt \ref{subsec:primitive-value-translation} und \cite{Doeraene2014}) und man Java runtime reflection nur sehr eingeschränkt nutzen kann. Insbesondere kann man aber Scala Code in beiden Welten also Bytecode und JS nutzen[webseite].

Mit Hilfe von implicit conversion und custom dynamic types war es möglich das JS Typsystem in das von Scala einzubetten ohne das von Scala zu verändern. Damit ist es möglich bestehende JS Bibliotheken dynamisch oder statisch getypt in Scala.js einzubinden. Was einen großen Vorteil bietet. 

Ein großer Nachteil für das Entwickeln von Webseiten ist, das man innerhalb von Scala Code der nach Bytecode übersetzt wird, keinen JS Code mit Hilfe von Scala.js erzeugen kann. Also man kann im erstellten JS Code nicht leicht auf die Serverumgebung, wie die momentane Session oder Datenbanken, zugreifen.

\section{js-scala}

js-scala ist eine Scala Bibliothek um JS Code zu erzeugen\cite{Kossakowski2012}. js-Scala benutzt dafür Lightweight Modular Staging (LMS)\cite{Rompf2010}. Dabei wird der in Scala geschriebene Code während der Übersetzung in eine Zwischendarstellung gebracht, die dann zur Laufzeit optimiert und in JS Code (oder auch in Scala Code) übersetzt wird. Das bringt einige Vorteile mit sich. 

Es ist möglich zur Laufzeit auf die Umgebung zu reagieren. Man kann entscheiden, ob man den Code in Scala oder JS ausführen möchte. Möchte man zum Beispiel mit JS ein Bild in einem HTML-canvas malen, aber der Browser des Benutzers unterstützt dies nicht, könnte man serverseitig mit Scala ein Bild malen und dies ausliefern. Natürlich kann man auch Daten aus der Laufzeitumgebung in den erzeugten JS-Code einbinden.

Zum anderen konnte gezeigt werden, das aus einer hohen Abstraktionsebene heraus, mit Hilfe der Optimierungen, sehr effizienter JS-Code generiert werden konnte\cite{Richard-Foy2013}.

Natürlich werden dies Vorteile durch mehr Aufwand während der Laufzeit erkauft. Das könnte man minimieren in dem man die Ergebnisse zwischenspeichert und/oder die Optimierungen einschränkt.

Wie auch in Scala.js, ist es in js-scala möglich JS-Bibliotheken in statisch oder dynamisch getypt einzubinden.


\section{SL in Scala}

Im Gegensatz zu allen anderen Ansätzen ist die Einbettung von SL in Scala sehr auf die Nutzung in Webservices beschränkt. Das liegt zum einen an der Verwendung von require.js zum Nachladen von Modulen. Dadurch ist es nicht möglich unabhängige JS Dateien zu erstellen. Zum anderen ist das Aufrufen von Scala-Funktionen über Ajax nur in einem solchen Kontext sinnvoll, aber auch besonders hilfreich.

Als Vorteil kann gesehen werden, das die beschreibende Sprache, also SL, sehr übersichtlich und ihre Grenzen klar sind. Weil die anderen Ansätze Scala als beschreibende Sprache benutzen kann dies zu Verwirrung führen. 

Ein besonders schwerwiegendes Manko ist die schwierige Einbindung von bereits existierenden JS-Bibliotheken. Dabei kommt eine Eigenschaft von SL besonders zum Tragen. Das Typsystem von SL kann keine JS-Objekte darstellen, die von den meisten Bibliotheken benutzt werden. Es bleibt nur die Möglichkeit Wrapper-Module zu erstellen, die massiv von JS-Quotings Gebrauch machen und um die Verwendung von Objekten herum arbeiten.

Zu erwähnen bleibt, das die momentane Implementation nur zeigen soll was mit SL in Scala möglich ist. Mögliche Verbesserungsvorschläge werden im Anhang \ref{sec:future-works} diskutiert.

\section{Zusammenfassung}

Die wichtigsten Eigenschaften der verschiedenen Ansätze werden in der Tabelle \ref{tab:related-work-overview} noch einmal zusammengefasst. Dabei soll folgendes Szenario angenommen werden. Ein Webserver bietet, eine in Scala geschriebene, Rich Internet Application an. Möglich wäre das Online-Postfach eines E-Mail-Anbieters wie gmail.com.

\begin{table}[ht]
\caption{Übersicht über die verschiedenen JS-in-Scala-Projekte}
\centering
\begin{tabular}{llll}
      & SL in Scala &  Scala.js              &    js-scala \\
 \midrule
Optimierung des JS Codes  &  keine  &  mit cloureScript & mit Hilfe von LMS\\
\addlinespace
Serveraufwand während & Wertübersetzung & keinen & erzeugen und  \\
einer Anfrage &  & & optimieren des JS Codes\\
\addlinespace
Nutzen von Servervariablen  & ja & nein & ja \\
während der Laufzeit & \\
\addlinespace
Abstraktion von Ajax-Anfragen & ja & nein & nein \\
\addlinespace
cross compiling & nein & ja & ja \\
\addlinespace
Einbinden von JS Bibliotheken & schwer & leicht & leicht \\

\end{tabular}
\label{tab:related-work-overview}
\end{table}

Aus meiner Sicht erscheint dabei js-scala besonders viel versprechend. Es vereint die meisten Vorteile und ist besonders flexibel. Mit ähnlichen Techniken wie in dieser Arbeit vorgestellt (siehe Abschnitt \ref{sec:annotation-macro}) sollte es möglich sein eine Abstraktion für Ajax-Anfragen zu implementieren.

\chapter{Fazit}
\label{chap:conclusion}

\appendix

\chapter{Future Works}
\label{sec:future-works}

\begin{itemize}
 \item{Security Aspekte beim Aufrufen von Scala Funktionen}
 \item{Play PlugIn bauen}
 \item{Erzeugen eines JAR's}
 \item{Erweiterung von SL um Objekte}
 \item{Einfachere Einbindung von JS Bibliotheken. Entweder mehr Module bauen <- viel Wartung oder unterstützung von dynamischen Objekten <- weniger typsicherheit}
 \item{Einen besser an Scala angepassten Syntax für SL}
 \item{Geht das mit require.js? Optimierung des generierten JS Codes. Am Anfang vllt mit ClojureScript}
\end{itemize}

\chapter{Beschreibung der Tests und Beispielprogramme}
\label{chap:tests-and-examples}

%TODO

\chapter{Benutzte Techniken/Bibliotheken}

%TODO webseiten noch einfügen
\begin{itemize}
  \item{Scala}
  \begin{itemize}
    \item{Scala v}
    \item{SBT v}
    \item{Play Framework v}
    \item{Macroparadise v}
    \item{json4s v}
  \end{itemize}
  \item{JavaScript}
  \begin{itemize}
    \item{JQuery v}
    \item{require.js v}
    \item{json.js v}
  \end{itemize}
  \item{Simple Language}
\end{itemize}



\chapter{HowTo's}

\section{Projekt aufsetzen}
\label{sec:setup-project}

\section{Einen neuen Translator anlegen}
\label{sec:new-translator-class}

\bibliography{powers.bib}{}
\bibliographystyle{geralpha}
\end{document}